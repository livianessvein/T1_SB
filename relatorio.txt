Livian Essvein 2211667 3WA e Luiza Regnier 2211931 3WB

* Relat√≥rio: T1 - Convers√£o entre UTF-8 e UTF-32

Introdu√ß√£o:
	Este relat√≥rio descreve o c√≥digo desenvolvido para a convers√£o de arquivos de texto entre os formatos UTF-8 e UTF-32. 
    O c√≥digo consiste em duas fun√ß√µes principais: convUtf8p32 e convUtf32p8.
	
O que est√° funcionando:
1. Leitura de arquivos: O c√≥digo consegue abrir e ler arquivos UTF-8 para a convers√£o.
2. Convers√£o de UTF-8 para UTF-32: A fun√ß√£o convUtf8p32 converte corretamente caracteres UTF-8 em UTF-32 e escreve o BOM adequado para arquivos UTF-32 little-endian.
3. Convers√£o de UTF-32 para UTF-8: A fun√ß√£o convUtf32p8 l√™ arquivos UTF-32 e converte os caracteres de volta para UTF-8, ignorando o BOM corretamente.
4. Fechamento de arquivos: Os arquivos s√£o fechados corretamente ap√≥s a leitura e a grava√ß√£o, evitando vazamentos de mem√≥ria.

Testes que fizemos:
    convUtf8p32: 
        teste 1: teste com o arquivo dado no enunciado
            -> Sa√≠da como o esperado, arquivo convertido com sucesso.

        teste 2: teste com um arquivo grande e com um emoji
            -> Por exemplo, o arquivo UTF8 com o texto "A long time ago in a gal√°xia üåç far, far away...", ao converter para UTF32 tem a hexdump igual a:
            
                    0000000 feff 0000 0041 0000 0020 0000 006c 0000
                    0000010 006f 0000 006e 0000 0067 0000 0020 0000
                    0000020 0074 0000 0069 0000 006d 0000 0065 0000
                    0000030 0020 0000 0061 0000 0067 0000 006f 0000
                    0000040 0020 0000 0069 0000 006e 0000 0020 0000
                    0000050 0061 0000 0020 0000 0067 0000 0061 0000
                    0000060 006c 0000 00e1 0000 0078 0000 0069 0000
                    0000070 0061 0000 0020 0000 f30d 0001 0020 0000
                    0000080 0066 0000 0061 0000 0072 0000 002c 0000
                    0000090 0020 0000 0066 0000 0061 0000 0072 0000
                    00000a0 0020 0000 0061 0000 0077 0000 0061 0000
                    00000b0 0079 0000 002e 0000 002e 0000 002e 0000
                    00000c0 000a 0000 000a 0000                    
                    00000c8


        teste 3: teste com o arquivo vazio
            -> Como o arquivo est√° vazio, no hexdump do arquivo utf8 n√£o gerou sa√≠da alguma. 
               J√° com o hexdump do arquivo utf32 convertido cont√©m apenas o caracter BOM, ou seja, sa√≠da esperada.
        
    convUtf32p8:
        teste 1: teste com o arquivo dado no enunciado
            -> Sa√≠da como o esperado, arquivo convertido com sucesso.
        
        teste 2: teste com arquivo vazio
            -> Como o arquivo est√° vazio, ou seja, n√£o existe nele o caracter BOM, ent√£o, deve haver erro na convers√£o, logo, sa√≠da esperada
            -> Sa√≠da esperada: Erro ao ler o BOM do arquivo de entrada.
                               Erro na convers√£o de UTF-32 para UTF-8.
        
        teste 3: teste com caracter BOM invalido
            -> Se o primeiro caracter d arquivo for diferente do BOM, a sa√≠da relatar√° o erro de BOM invalido e n√£o far√° a convers√£o.
            -> Exemplo de sa√≠da: BOM inv√°lido: 0x53FEFF
                                 Erro na convers√£o de UTF-32 para UTF-8.



O que n√£o est√° funcionando:
 - A princ√≠pio, nosso grupo n√£o achou algo que n√£o funcione
 

Conclus√£o:
    O c√≥digo apresenta uma boa base para a convers√£o entre UTF-8 e UTF-32. 
    A fun√ß√£o converte8p32 tamb√©m testa os bytes iniciais e de continua√ß√£o para cada caracter lido, mas como o arquivo utf8 de entrada estava sempre
    codificada corretamente n√£o foi possivel implementar um teste.